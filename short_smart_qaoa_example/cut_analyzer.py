# Smart QAOA short example by ⚛️ Sigma PublishinQ Team ⚛️  
# https://www.linkedin.com/company/sigma-publishinq/about/

"""
Functions for computing graph-cut and MaxCut of graphs using QOKit API.
"""

from dataclasses import dataclass
from typing import Set, List, Tuple, Optional
import numpy as np
import networkx as nx
import sys
import os
sys.path.append('/content/drive/MyDrive/QOKit_enhanced_MLMVN/QOKit/')
from qokit.energy_maxcut import maxcut_obj
from qokit.maxcut import get_adjacency_matrix


@dataclass
class BruteForceResult:
    """
    Container for data generated by brute_force_maxcut function.

    Attributes:
        partitions_scores: list of (partition, score) for all possible partitions
        best_score: best possible MaxCut score for analyzed graph
        optimal_partitions: all partitions that give the best score
    """
    partitions_scores: List[Tuple[str, int]]
    best_score: int
    optimal_partitions: Set[str]


def compute_cut_score(graph: nx.Graph, bitstring: str) -> int:
    """
    Computes cut score for given graph and partition (defined by bitstring).
    
    Args:
        graph: graph to compute cut score for
        bitstring: bitstring defining graph partition into 2 subsets
        
    Returns:
        Cut score of bitstring relative to graph
    """
    # Get adjacency matrix through QOKit
    w = get_adjacency_matrix(graph)
    
    # Convert bitstring to array (invert for little-endian)
    x = np.array([int(bit) for bit in bitstring[::-1]])
    
    # Use maxcut_obj function from QOKit
    # It returns negative value, so take absolute value
    return int(abs(maxcut_obj(x, w)))


def brute_force_maxcut(graph: nx.Graph, num_blue_nodes: Optional[int] = None) -> BruteForceResult:
    """
    Checks all possible vertex partitions of graph using brute force method.
    
    Args:
        graph: graph to solve MaxCut problem for
        num_blue_nodes: if specified, considers only partitions with given number of vertices in one subset
        
    Returns:
        Complete MaxCut analysis for given graph
    """
    scores_dict = {}
    num_nodes = graph.number_of_nodes()
    
    # Iterate through all possible partitions
    for num in range(2 ** num_nodes):
        bitstring = bin(num)[2:].zfill(num_nodes)
        
        # Filter by number of nodes in subset if specified
        if num_blue_nodes is not None and bitstring.count("1") != num_blue_nodes:
            continue
            
        scores_dict[bitstring] = compute_cut_score(graph, bitstring)
    
    # Sort by score (descending)
    partitions_scores = sorted(scores_dict.items(), key=lambda item: item[1], reverse=True)
    best_score = partitions_scores[0][1]
    
    # Find all optimal partitions
    optimal_partitions = set()
    for partition, score in partitions_scores:
        if score < best_score:
            break
        optimal_partitions.add(partition)
    
    return BruteForceResult(partitions_scores, best_score, optimal_partitions)


def evaluate_qaoa_performance(graph: nx.Graph, qaoa_energy: float) -> float:
    """
    Evaluates QAOA performance by computing approximation ratio.
    
    Args:
        graph: graph to analyze
        qaoa_energy: energy obtained from QAOA (negative value)
        
    Returns:
        Approximation ratio (qaoa_cut / optimal_cut)
    """
    # Find optimal cut
    brute_force_result = brute_force_maxcut(graph)
    optimal_cut = brute_force_result.best_score
    
    # QAOA returns negative energy, so take absolute value
    qaoa_cut = abs(qaoa_energy)
    
    # Compute approximation ratio
    if optimal_cut == 0:
        return 1.0 if qaoa_cut == 0 else 0.0
    
    return qaoa_cut / optimal_cut


def compare_solutions(graph: nx.Graph, qaoa_params: np.ndarray, qaoa_objective_func) -> dict:
    """
    Compares QAOA solution with optimal solution.
    
    Args:
        graph: graph to analyze
        qaoa_params: QAOA parameters
        qaoa_objective_func: function to compute QAOA energy
        
    Returns:
        Dictionary with comparison results
    """
    # Compute QAOA energy
    qaoa_energy = qaoa_objective_func(qaoa_params)
    
    # Find optimal solution
    brute_force_result = brute_force_maxcut(graph)
    
    # Compute approximation ratio
    approximation_ratio = evaluate_qaoa_performance(graph, qaoa_energy)
    
    return {
        'qaoa_energy': qaoa_energy,
        'qaoa_cut': abs(qaoa_energy),
        'optimal_cut': brute_force_result.best_score,
        'approximation_ratio': approximation_ratio,
        'num_optimal_partitions': len(brute_force_result.optimal_partitions),
        'optimal_partitions': brute_force_result.optimal_partitions
    }